
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>opihiexarata.library.image &#8212; OpihiExarata 2021.12.9 documentation</title>
    
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/scrolls.css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/theme_extras.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div id="content">
      <div class="header">
        <h1 class="heading"><a href="../../../index.html"
          title="back to the documentation overview"><span>opihiexarata.library.image</span></a></h1>
      </div>
      <div class="relnav" role="navigation" aria-label="related navigation">
        <a href="#">opihiexarata.library.image</a>
      </div>
      <div id="contentwrapper">
        <div role="main">
        
  <h1>Source code for opihiexarata.library.image</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Functions to help with image and array manipulations.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">PIL.Image</span>

<span class="kn">import</span> <span class="nn">opihiexarata.library</span> <span class="k">as</span> <span class="nn">library</span>
<span class="kn">import</span> <span class="nn">opihiexarata.library.error</span> <span class="k">as</span> <span class="nn">error</span>
<span class="kn">import</span> <span class="nn">opihiexarata.library.hint</span> <span class="k">as</span> <span class="nn">hint</span>


<div class="viewcode-block" id="slice_array_boundary"><a class="viewcode-back" href="../../../code/opihiexarata.library.image.html#opihiexarata.library.image.slice_array_boundary">[docs]</a><span class="k">def</span> <span class="nf">slice_array_boundary</span><span class="p">(</span>
    <span class="n">array</span><span class="p">:</span> <span class="n">hint</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="n">x_min</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">x_max</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y_min</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y_max</span><span class="p">:</span> <span class="nb">int</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hint</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Slice an image array such that it stops at the boundaries and does not</span>
<span class="sd">    exceed past it. This function basically handels runtime slicing, but it</span>
<span class="sd">    returns a copy.</span>

<span class="sd">    This function does not wrap around slices.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : array-like</span>
<span class="sd">        The base array which the slice will access.</span>
<span class="sd">    x_min : int</span>
<span class="sd">        The lower index bound of the x-axis slice.</span>
<span class="sd">    x_max : int</span>
<span class="sd">        The upper index bound of the x-axis slice.</span>
<span class="sd">    y_min : int</span>
<span class="sd">        The lower index bound of the y-axis slice.</span>
<span class="sd">    y_max : int</span>
<span class="sd">        The upper index bound of the y-axis slice.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    boundary_sliced_array : array-like</span>
<span class="sd">        The array, sliced while adhering to the boundary of the slices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># The maximum value that a slice can have is determined by their column</span>
    <span class="c1"># and row count.</span>
    <span class="n">n_rows</span><span class="p">,</span> <span class="n">n_cols</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1"># Negative slices are already invalid and out of bounds.</span>
    <span class="n">x_min</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">x_min</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">x_min</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">n_cols</span> <span class="k">if</span> <span class="n">x_max</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">x_max</span>
    <span class="n">y_min</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">y_min</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">y_min</span>
    <span class="n">y_max</span> <span class="o">=</span> <span class="n">n_rows</span> <span class="k">if</span> <span class="n">y_max</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">y_max</span>
    <span class="c1"># Likewise, if any of the indexes exceed the bounds of the array, force</span>
    <span class="c1"># them back.</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">n_cols</span> <span class="k">if</span> <span class="n">n_cols</span> <span class="o">&lt;</span> <span class="n">x_max</span> <span class="k">else</span> <span class="n">x_max</span>
    <span class="n">y_max</span> <span class="o">=</span> <span class="n">n_rows</span> <span class="k">if</span> <span class="n">n_rows</span> <span class="o">&lt;</span> <span class="n">y_max</span> <span class="k">else</span> <span class="n">y_max</span>
    <span class="c1"># Return the slice with these bounds.</span>
    <span class="n">boundary_sliced_array</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">y_min</span><span class="p">:</span><span class="n">y_max</span><span class="p">,</span> <span class="n">x_min</span><span class="p">:</span><span class="n">x_max</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">boundary_sliced_array</span></div>


<div class="viewcode-block" id="scale_image_array"><a class="viewcode-back" href="../../../code/opihiexarata.library.image.html#opihiexarata.library.image.scale_image_array">[docs]</a><span class="k">def</span> <span class="nf">scale_image_array</span><span class="p">(</span>
    <span class="n">array</span><span class="p">:</span> <span class="n">hint</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">minimum</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">maximum</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">lower_percent_cut</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">upper_percent_cut</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hint</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;This function scales the array to the provided minimum and maximum</span>
<span class="sd">    ranges after the percentile masks are taken.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : array-like</span>
<span class="sd">        The array to be scaled.</span>
<span class="sd">    minimum : float</span>
<span class="sd">        The minimum value of the scaling axis. This will be equal to the</span>
<span class="sd">        minimum value of the scaled array after accounting for the percentile</span>
<span class="sd">        cuts.</span>
<span class="sd">    maximum : float</span>
<span class="sd">        The maximum value of the scaling axis. This will be equal to the</span>
<span class="sd">        maximum value of the scaled array after accounting for the percentile</span>
<span class="sd">        cuts.</span>
<span class="sd">    lower_percent_cut : float</span>
<span class="sd">        The percent of values that will be masked from the lower end. Must be</span>
<span class="sd">        between 0-100.</span>
<span class="sd">    upper_percent_cut : float</span>
<span class="sd">        The percent of values that will be masked from the upper end. Must be</span>
<span class="sd">        between 0-100.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    scaled_array : array-like</span>
<span class="sd">        The array, after the scaling.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Ensure that the percentile values are within percentile ranges.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">lower_percent_cut</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">error</span><span class="o">.</span><span class="n">InputError</span><span class="p">(</span>
            <span class="s2">&quot;The lower percentile cut should be between 0 &lt;= x &lt;= 100. You provided:&quot;</span>
            <span class="s2">&quot; </span><span class="si">{value}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">lower_percent_cut</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">upper_percent_cut</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">error</span><span class="o">.</span><span class="n">InputError</span><span class="p">(</span>
            <span class="s2">&quot;The upper percentile cut should be between 0 &lt;= x &lt;= 100. You provided:&quot;</span>
            <span class="s2">&quot; </span><span class="si">{value}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">upper_percent_cut</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="c1"># Find where to mask out using the percentile cuts.</span>
    <span class="n">lower_cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">lower_percent_cut</span><span class="p">)</span>
    <span class="n">upper_cut</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanpercentile</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="mi">100</span> <span class="o">-</span> <span class="n">upper_percent_cut</span><span class="p">)</span>
    <span class="n">invalid_pixels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">lower_cut</span> <span class="o">&lt;=</span> <span class="n">array</span><span class="p">,</span> <span class="n">array</span> <span class="o">&lt;=</span> <span class="n">upper_cut</span><span class="p">),</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span>
    <span class="p">)</span>
    <span class="c1"># Mask out those values which are invalid.</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">array</span><span class="p">[</span><span class="n">invalid_pixels</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="n">array</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">array</span><span class="p">)]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="c1"># Scale the array via linear interpolation.</span>
    <span class="n">a_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">a_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="n">scaled_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="p">(</span><span class="n">a_min</span><span class="p">,</span> <span class="n">a_max</span><span class="p">),</span> <span class="p">(</span><span class="n">minimum</span><span class="p">,</span> <span class="n">maximum</span><span class="p">))</span>
    <span class="c1"># Ensuring the invalid pixels are still invalid.</span>
    <span class="n">scaled_array</span><span class="p">[</span><span class="n">invalid_pixels</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">return</span> <span class="n">scaled_array</span></div>


<div class="viewcode-block" id="create_circular_mask"><a class="viewcode-back" href="../../../code/opihiexarata.library.image.html#opihiexarata.library.image.create_circular_mask">[docs]</a><span class="k">def</span> <span class="nf">create_circular_mask</span><span class="p">(</span>
    <span class="n">array</span><span class="p">:</span> <span class="n">hint</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="n">center_x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">center_y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">radius</span><span class="p">:</span> <span class="nb">float</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hint</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Creates an array which is a circular mask of some radius centered at a</span>
<span class="sd">    custom index value location. This process is a little intensive so using</span>
<span class="sd">    smaller subsets of arrays are preferred.</span>

<span class="sd">    Method inspired by https://stackoverflow.com/a/44874588.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : array-like</span>
<span class="sd">        The data array which the mask will base itself off of. The data in the</span>
<span class="sd">        array is not actually modified but it is required for the shape</span>
<span class="sd">        definition.</span>
<span class="sd">    center_x : integer</span>
<span class="sd">        The x-axis coordinate where the mask will be centered.</span>
<span class="sd">    center_y : integer</span>
<span class="sd">        The y-axis coordinate where the mask will be centered.</span>
<span class="sd">    radius : float</span>
<span class="sd">        The radius of the circle of the mask in pixels.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    circular_mask : array-like</span>
<span class="sd">        The mask; it is the same dimensions of the input data array. If True,</span>
<span class="sd">        the the mask should be applied.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Creating an array to make the circle, it should be just big enough to</span>
    <span class="c1"># create the circle but not too big to have unneeded calculations. To</span>
    <span class="c1"># ensure that it is centered, the array should have odd widths.</span>
    <span class="n">width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">radius</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span>
    <span class="n">width</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">width</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">working_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Performing the circular mask calculation on this middle region.</span>
    <span class="n">near_n_rows</span><span class="p">,</span> <span class="n">near_n_cols</span> <span class="o">=</span> <span class="n">working_array</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">near_center_x</span> <span class="o">=</span> <span class="n">near_n_rows</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">near_center_y</span> <span class="o">=</span> <span class="n">near_n_cols</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">grid_y</span><span class="p">,</span> <span class="n">grid_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ogrid</span><span class="p">[:</span><span class="n">near_n_rows</span><span class="p">,</span> <span class="p">:</span><span class="n">near_n_cols</span><span class="p">]</span>
    <span class="n">dist_sq</span> <span class="o">=</span> <span class="p">(</span><span class="n">grid_x</span> <span class="o">-</span> <span class="n">near_center_x</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">grid_y</span> <span class="o">-</span> <span class="n">near_center_y</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">near_mask</span> <span class="o">=</span> <span class="n">dist_sq</span> <span class="o">&lt;=</span> <span class="n">radius</span> <span class="o">**</span> <span class="mi">2</span>

    <span class="c1"># The circular mask is local and should be expanded to the full array&#39;s</span>
    <span class="c1"># size. Padding is needed in the event that the center pixel is on the</span>
    <span class="c1"># edge as the arrays are co-aligned.</span>
    <span class="n">center_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">center_x</span><span class="p">)</span>
    <span class="n">center_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">center_y</span><span class="p">)</span>
    <span class="n">half_width</span> <span class="o">=</span> <span class="n">width</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">base_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full_like</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
    <span class="n">padded_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">base_mask</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">center_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">center_x</span><span class="p">)</span> <span class="o">+</span> <span class="n">width</span>
    <span class="n">center_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">center_y</span><span class="p">)</span> <span class="o">+</span> <span class="n">width</span>
    <span class="n">padded_mask</span><span class="p">[</span>
        <span class="n">center_y</span> <span class="o">-</span> <span class="n">half_width</span> <span class="p">:</span> <span class="n">center_y</span> <span class="o">+</span> <span class="n">half_width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">center_x</span> <span class="o">-</span> <span class="n">half_width</span> <span class="p">:</span> <span class="n">center_x</span> <span class="o">+</span> <span class="n">half_width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">near_mask</span>
    <span class="c1"># Reshape the padded mask to the proper size, the same as the input array.</span>
    <span class="n">circular_mask</span> <span class="o">=</span> <span class="n">padded_mask</span><span class="p">[</span><span class="n">width</span><span class="p">:</span><span class="o">-</span><span class="n">width</span><span class="p">,</span> <span class="n">width</span><span class="p">:</span><span class="o">-</span><span class="n">width</span><span class="p">]</span>
    <span class="c1"># As per Numpy, masked values are considered True in the mask. The current</span>
    <span class="c1"># method above creates a circle of True values, so the real mask is the</span>
    <span class="c1"># inverse.</span>
    <span class="n">circular_mask</span> <span class="o">=</span> <span class="o">~</span><span class="n">circular_mask</span>
    <span class="k">return</span> <span class="n">circular_mask</span></div>


<div class="viewcode-block" id="save_array_as_png_grayscale"><a class="viewcode-back" href="../../../code/opihiexarata.library.image.html#opihiexarata.library.image.save_array_as_png_grayscale">[docs]</a><span class="k">def</span> <span class="nf">save_array_as_png_grayscale</span><span class="p">(</span>
    <span class="n">array</span><span class="p">:</span> <span class="n">hint</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;This converts an array to a grayscale PNG file.</span>

<span class="sd">    The PNG specification requires that the data values be integer. Note that</span>
<span class="sd">    if you are saving an array as a PNG, then data may be lost during the</span>
<span class="sd">    conversion between float to integer.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array : array-like</span>
<span class="sd">        The array that will be saved as a png.</span>
<span class="sd">    filename : string</span>
<span class="sd">        The filename where the png will be saved. If the filename does not have</span>
<span class="sd">        the appropriate filename extension, it will be appended.</span>
<span class="sd">    overwrite : boolean</span>
<span class="sd">        If the file already exists, should it be overwritten?</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check the extension.</span>
    <span class="n">user_ext</span> <span class="o">=</span> <span class="n">library</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">get_file_extension</span><span class="p">(</span><span class="n">pathname</span><span class="o">=</span><span class="n">filename</span><span class="p">)</span>
    <span class="n">valid_ext</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;png&quot;</span><span class="p">,)</span>
    <span class="k">if</span> <span class="n">user_ext</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_ext</span><span class="p">:</span>
        <span class="c1"># Adding the extension.</span>
        <span class="n">preferred_ext</span> <span class="o">=</span> <span class="n">valid_ext</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">filename_png</span> <span class="o">=</span> <span class="n">library</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">merge_pathname</span><span class="p">(</span>
            <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="n">preferred_ext</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">filename_png</span> <span class="o">=</span> <span class="n">filename</span>
    <span class="c1"># Check if the file already exists, if it does, check if overwriting was</span>
    <span class="c1"># allowed.</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename_png</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="c1"># Overwrite the file by deleting it.</span>
            <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">filename_png</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">error</span><span class="o">.</span><span class="n">FileError</span><span class="p">(</span>
                <span class="s2">&quot;The png file already exists. Overwrite is False. The image cannot be&quot;</span>
                <span class="s2">&quot; saved at the specified path: </span><span class="si">{path}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">filename_png</span><span class="p">)</span>
            <span class="p">)</span>
    <span class="c1"># Finally, scale the file.</span>
    <span class="n">image_object</span> <span class="o">=</span> <span class="n">PIL</span><span class="o">.</span><span class="n">Image</span><span class="o">.</span><span class="n">fromarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="s2">&quot;L&quot;</span><span class="p">)</span>
    <span class="n">image_object</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filename_png</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">None</span></div>
</pre></div>

        </div>
      </div>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, Kenji Sparrow Emerson.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.3.1.
    </div>
  </body>
</html>